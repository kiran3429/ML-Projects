# -*- coding: utf-8 -*-
"""forestcover.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CE_8olsECY8RxmdHMn_r95UWWobYOIsG
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install catboost

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, accuracy_score
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier
from sklearn.ensemble import VotingClassifier
import joblib
import random
import os

SEED = 42
np.random.seed(SEED)
random.seed(SEED)
os.environ['PYTHONHASHSEED'] = str(SEED)

df = pd.read_csv("/content/train.csv")
df = df.drop(columns=["Id"])

X = df.drop("Cover_Type", axis=1)
y = df["Cover_Type"] - 1

# Drop rows where y is NaN
nan_rows = y.isna()
X = X[~nan_rows]
y = y[~nan_rows]

X["Mean_Hillshade"] = (X["Hillshade_9am"] + X["Hillshade_Noon"] + X["Hillshade_3pm"]) / 3
X["Road_Fire_Diff"] = abs(X["Horizontal_Distance_To_Roadways"] - X["Horizontal_Distance_To_Fire_Points"])
X["Hydro_Road_Diff"] = abs(X["Horizontal_Distance_To_Hydrology"] - X["Horizontal_Distance_To_Roadways"])
X["Elevation_Slope_Ratio"] = X["Elevation"] / (X["Slope"] + 1)

num_cols = ["Elevation", "Aspect", "Slope",
            "Horizontal_Distance_To_Hydrology", "Vertical_Distance_To_Hydrology",
            "Horizontal_Distance_To_Roadways", "Hillshade_9am", "Hillshade_Noon",
            "Hillshade_3pm", "Horizontal_Distance_To_Fire_Points",
            "Mean_Hillshade", "Road_Fire_Diff", "Hydro_Road_Diff", "Elevation_Slope_Ratio"]

scaler = StandardScaler()
X[num_cols] = scaler.fit_transform(X[num_cols])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=SEED)

feature_columns = X_train.columns.tolist()

xgb_model = XGBClassifier(
    n_estimators=900,
    max_depth=12,
    learning_rate=0.04,
    subsample=0.8,
    colsample_bytree=0.8,
    objective='multi:softmax',
    num_class=7,
    random_state=SEED,
    eval_metric='mlogloss',
    tree_method="hist"
)

lgb_model = LGBMClassifier(
    n_estimators=900,
    max_depth=12,
    learning_rate=0.04,
    subsample=0.8,
    colsample_bytree=0.8,
    objective='multiclass',
    num_class=7,
    random_state=SEED,
    deterministic=True
)

cat_model = CatBoostClassifier(
    iterations=900,
    depth=12,
    learning_rate=0.04,
    loss_function='MultiClass',
    verbose=0,
    random_seed=SEED
)

ensemble_model = VotingClassifier(
    estimators=[
        ('xgb', xgb_model),
        ('lgb', lgb_model),
        ('cat', cat_model)
    ],
    voting='soft',
    weights=[2, 1, 2]  # give higher weight to XGB and CatBoost
)

ensemble_model.fit(X_train, y_train)

y_pred = ensemble_model.predict(X_test)
print(classification_report(y_test + 1, y_pred + 1))

import joblib
from google.colab import drive

drive.mount('/content/drive')

joblib.dump(ensemble_model, "/content/drive/MyDrive/forest_cover_ensemble.pkl")
print(" Model saved to Google Drive!")

import joblib
from google.colab import drive


drive.mount('/content/drive')

# Load the trained model
model_path = "/content/drive/MyDrive/forest_cover_ensemble.pkl"
ensemble_model = joblib.load(model_path)

print("Model loaded successfully!")

# Required library
!pip install ipywidgets --quiet

import ipywidgets as widgets
from IPython.display import display, clear_output
import pandas as pd

def interactive_predict(Elevation, Aspect, Slope,
                        Horizontal_Distance_To_Hydrology,
                        Vertical_Distance_To_Hydrology,
                        Horizontal_Distance_To_Roadways,
                        Hillshade_9am, Hillshade_Noon, Hillshade_3pm,
                        Horizontal_Distance_To_Fire_Points,
                        Wilderness, Soil):

    # Derived features
    Mean_Hillshade = (Hillshade_9am + Hillshade_Noon + Hillshade_3pm) / 3
    Road_Fire_Diff = abs(Horizontal_Distance_To_Roadways - Horizontal_Distance_To_Fire_Points)
    Hydro_Road_Diff = abs(Horizontal_Distance_To_Hydrology - Horizontal_Distance_To_Roadways)
    Elevation_Slope_Ratio = Elevation / (Slope + 1)

    # Wilderness binary
    Wilderness_bin = [0]*4
    if Wilderness != 0:
        Wilderness_bin[Wilderness - 1] = 1

    # Soil binary
    Soil_bin = [0]*40
    if Soil != 0:
        Soil_bin[Soil - 1] = 1

    # Combine all features
    data_dict = {
        "Elevation": [Elevation],
        "Aspect": [Aspect],
        "Slope": [Slope],
        "Horizontal_Distance_To_Hydrology": [Horizontal_Distance_To_Hydrology],
        "Vertical_Distance_To_Hydrology": [Vertical_Distance_To_Hydrology],
        "Horizontal_Distance_To_Roadways": [Horizontal_Distance_To_Roadways],
        "Hillshade_9am": [Hillshade_9am],
        "Hillshade_Noon": [Hillshade_Noon],
        "Hillshade_3pm": [Hillshade_3pm],
        "Horizontal_Distance_To_Fire_Points": [Horizontal_Distance_To_Fire_Points],
        "Mean_Hillshade": [Mean_Hillshade],
        "Road_Fire_Diff": [Road_Fire_Diff],
        "Hydro_Road_Diff": [Hydro_Road_Diff],
        "Elevation_Slope_Ratio": [Elevation_Slope_Ratio],
    }

    for i in range(4):
        data_dict[f"Wilderness_Area{i+1}"] = [Wilderness_bin[i]]
    for i in range(40):
        data_dict[f"Soil_Type{i+1}"] = [Soil_bin[i]]

    input_df = pd.DataFrame(data_dict)
    # Scale numeric columns
    input_df[num_cols] = scaler.transform(input_df[num_cols])
    # Reorder columns exactly as training
    input_df = input_df[feature_columns]

    # Predict
    prediction = ensemble_model.predict(input_df)[0]
    cover_mapping = {
        1: "Spruce/Fir",
        2: "Lodgepole Pine",
        3: "Ponderosa Pine",
        4: "Cottonwood/Willow",
        5: "Aspen",
        6: "Douglas-fir",
        7: "Krummholz"
    }

    clear_output(wait=True)
    print(f"ðŸŒ² Predicted Forest Cover Type: {prediction} - {cover_mapping[int(prediction)]}")

# Widgets for numeric inputs
Elevation_w = widgets.IntSlider(min=2000, max=4000, step=1, value=2600, description='Elevation')
Aspect_w = widgets.IntSlider(min=0, max=360, step=1, value=100, description='Aspect')
Slope_w = widgets.IntSlider(min=0, max=60, step=1, value=10, description='Slope')
HorHydro_w = widgets.IntSlider(min=0, max=5000, step=1, value=200, description='HorDistHydro')
VerHydro_w = widgets.IntSlider(min=-100, max=500, step=1, value=20, description='VerDistHydro')
HorRoad_w = widgets.IntSlider(min=0, max=5000, step=1, value=1000, description='HorDistRoad')
Hill9_w = widgets.IntSlider(min=0, max=255, step=1, value=210, description='Hillshade9am')
HillNoon_w = widgets.IntSlider(min=0, max=255, step=1, value=230, description='HillshadeNoon')
Hill3_w = widgets.IntSlider(min=0, max=255, step=1, value=150, description='Hillshade3pm')
HorFire_w = widgets.IntSlider(min=0, max=7000, step=1, value=700, description='HorDistFire')

# Widgets for categorical inputs
Wilderness_w = widgets.Dropdown(options=[(f'Unknown', 0), ('1', 1), ('2', 2), ('3', 3), ('4', 4)],
                                description='Wilderness')
Soil_w = widgets.Dropdown(options=[('Unknown', 0)] + [(str(i), i) for i in range(1, 41)],
                          description='Soil')

ui = widgets.VBox([Elevation_w, Aspect_w, Slope_w, HorHydro_w, VerHydro_w, HorRoad_w,
                   Hill9_w, HillNoon_w, Hill3_w, HorFire_w, Wilderness_w, Soil_w])

out = widgets.interactive_output(interactive_predict,
                                {'Elevation': Elevation_w,
                                 'Aspect': Aspect_w,
                                 'Slope': Slope_w,
                                 'Horizontal_Distance_To_Hydrology': HorHydro_w,
                                 'Vertical_Distance_To_Hydrology': VerHydro_w,
                                 'Horizontal_Distance_To_Roadways': HorRoad_w,
                                 'Hillshade_9am': Hill9_w,
                                 'Hillshade_Noon': HillNoon_w,
                                 'Hillshade_3pm': Hill3_w,
                                 'Horizontal_Distance_To_Fire_Points': HorFire_w,
                                 'Wilderness': Wilderness_w,
                                 'Soil': Soil_w})

display(ui, out)