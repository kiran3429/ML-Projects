# -*- coding: utf-8 -*-
"""Heart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MY_6yJxUVuCvAaGqdipLA7ip4228klq1
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score, GridSearchCV
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import (
    accuracy_score, precision_score, recall_score, f1_score,
    roc_auc_score, classification_report,
    ConfusionMatrixDisplay, RocCurveDisplay
)
import joblib

df = pd.read_csv("/content/dataset.csv")

print("‚úÖ Dataset loaded successfully!")
print("Shape:", df.shape)
display(df.head())

df.columns = [c.strip().lower().replace(" ", "_") for c in df.columns]

print("\nColumns after cleaning:")
print(df.columns.tolist())

print("\nMissing values before handling:")
print(df.isnull().sum())

# Replace blanks or '?' with NaN (if any)
df = df.replace(['?', ' '], np.nan)

# Convert all numeric columns that are object type to float
for col in df.columns:
    if df[col].dtype == 'object':
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Print missing count again
print("\nMissing values after conversion:")
print(df.isnull().sum())

print("\nTarget distribution:")
print(df['target'].value_counts(normalize=True))

sns.countplot(data=df, x='target')
plt.title("Target Class Distribution")
plt.show()

X = df.drop(columns=['target'])
y = df['target']

numeric_cols = ['age', 'resting_bp_s', 'cholesterol', 'max_heart_rate', 'oldpeak']
binary_cols = ['sex', 'fasting_blood_sugar', 'exercise_angina']
nominal_cols = ['chest_pain_type', 'resting_ecg', 'st_slope']

numeric_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore'))
])

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_cols),
        ('cat', categorical_transformer, nominal_cols + binary_cols)
    ])

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42)

print("\n‚úÖ Data split complete")
print("Train shape:", X_train.shape)
print("Test shape:", X_test.shape)

rf_pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('rf', RandomForestClassifier(
        n_estimators=200,
        max_depth=None,
        class_weight='balanced',
        random_state=42))
])

cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
cv_scores = cross_val_score(rf_pipeline, X_train, y_train, cv=cv, scoring='roc_auc')
print(f"\nAverage ROC-AUC (CV): {cv_scores.mean():.3f} ¬± {cv_scores.std():.3f}")

rf_pipeline.fit(X_train, y_train)
print("\n‚úÖ Model training complete!")

y_pred = rf_pipeline.predict(X_test)
y_prob = rf_pipeline.predict_proba(X_test)[:, 1]

print("\n--- Test Results ---")
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Precision:", precision_score(y_test, y_pred))
print("Recall:", recall_score(y_test, y_pred))
print("F1 Score:", f1_score(y_test, y_pred))
print("ROC AUC:", roc_auc_score(y_test, y_prob))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Plot Confusion Matrix & ROC
ConfusionMatrixDisplay.from_predictions(y_test, y_pred)
plt.show()
RocCurveDisplay.from_predictions(y_test, y_prob)
plt.show()

ohe = rf_pipeline.named_steps['preprocessor'].named_transformers_['cat'].named_steps['onehot']
ohe_cols = list(ohe.get_feature_names_out(nominal_cols + binary_cols))
feature_names = numeric_cols + ohe_cols

rf = rf_pipeline.named_steps['rf']
importances = pd.Series(rf.feature_importances_, index=feature_names).sort_values(ascending=False)

print("\nTop 10 Important Features:")
display(importances.head(10))

plt.figure(figsize=(8, 5))
sns.barplot(x=importances.head(10), y=importances.head(10).index)
plt.title("Top 10 Feature Importances (Random Forest)")
plt.show()

joblib.dump(rf_pipeline, "heart_rf_model.joblib")
print(" Model saved to heart_rf_model.joblib")

sample = X_test.iloc[0:1]
pred_prob = rf_pipeline.predict_proba(sample)[0,1]
pred_class = rf_pipeline.predict(sample)[0]
print("\nSample Prediction ‚Üí Probability of Heart Disease:", round(pred_prob,3))
print("Predicted Class (1 = Disease, 0 = Normal):", pred_class)

import ipywidgets as widgets
from IPython.display import display, clear_output

def interactive_predict(age, sex, chestpain, restingbps, cholesterol,
                        fastingbs, restingecg, maxheartrate, exerciseangina,
                        oldpeak, STslope):

    # Build input DataFrame
    input_dict = {
        "age": [age],
        "sex": [sex],
        "chest_pain_type": [chestpain],
        "resting_bp_s": [restingbps],
        "cholesterol": [cholesterol],
        "fasting_blood_sugar": [fastingbs],
        "resting_ecg": [restingecg],
        "max_heart_rate": [maxheartrate],
        "exercise_angina": [exerciseangina],
        "oldpeak": [oldpeak],
        "st_slope": [STslope]
    }

    input_df = pd.DataFrame(input_dict)

    # Load the saved model
    rf_pipeline_loaded = joblib.load("heart_rf_model.joblib")

    # Predict
    pred = rf_pipeline_loaded.predict(input_df)[0]

    clear_output(wait=True)
    print("ü©∫ HEART DISEASE PREDICTION SYSTEM")
    print("----------------------------------")
    print(f"üë§ Age: {age}, Sex: {'Male' if sex==1 else 'Female'}")
    print(f"‚ù§Ô∏è Chest Pain Type: {chestpain}")
    print(f"üíâ Cholesterol: {cholesterol} mg/dL")
    print(f"üèÉ Max Heart Rate: {maxheartrate}")
    print(f"‚ö° Oldpeak: {oldpeak}")
    print("----------------------------------")
    print("‚úÖ Prediction:", "Heart Disease" if pred==1 else "Normal")

# =========================================
# üßç INPUT WIDGETS FOR USER INTERACTION
# =========================================

age_w = widgets.IntSlider(min=20, max=100, value=50, description='Age')
sex_w = widgets.Dropdown(options=[('Female',0), ('Male',1)], description='Sex')
chestpain_w = widgets.Dropdown(
    options=[('Typical Angina',1), ('Atypical Angina',2), ('Non-Anginal Pain',3), ('Asymptomatic',4)],
    description='Chest Pain'
)
restingbps_w = widgets.IntSlider(min=80, max=200, value=120, description='Rest BP (mmHg)')
cholesterol_w = widgets.IntSlider(min=100, max=400, value=200, description='Chol (mg/dL)')
fastingbs_w = widgets.Dropdown(options=[('<=120 mg/dL',0), ('>120 mg/dL',1)], description='Fasting Sugar')
restingecg_w = widgets.Dropdown(
    options=[('Normal',0), ('ST-T Abnormality',1), ('LV Hypertrophy',2)],
    description='Rest ECG'
)
maxheartrate_w = widgets.IntSlider(min=60, max=220, value=150, description='Max HR')
exerciseangina_w = widgets.Dropdown(options=[('No',0), ('Yes',1)], description='Exercise Angina')
oldpeak_w = widgets.FloatSlider(min=0.0, max=6.5, step=0.1, value=1.0, description='Oldpeak')
STslope_w = widgets.Dropdown(
    options=[('Upward',1), ('Flat',2), ('Downward',3)],
    description='ST Slope'
)

# Group all widgets
ui = widgets.VBox([
    age_w, sex_w, chestpain_w, restingbps_w, cholesterol_w, fastingbs_w,
    restingecg_w, maxheartrate_w, exerciseangina_w, oldpeak_w, STslope_w
])

# Output interactive display
out = widgets.interactive_output(
    interactive_predict,
    {
        'age': age_w,
        'sex': sex_w,
        'chestpain': chestpain_w,
        'restingbps': restingbps_w,
        'cholesterol': cholesterol_w,
        'fastingbs': fastingbs_w,
        'restingecg': restingecg_w,
        'maxheartrate': maxheartrate_w,
        'exerciseangina': exerciseangina_w,
        'oldpeak': oldpeak_w,
        'STslope': STslope_w
    }
)

display(ui, out)

